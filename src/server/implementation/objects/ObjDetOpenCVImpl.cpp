/* Autogenerated with kurento-module-creator */
#include "ModelPool.hpp"

#include "ObjDetOpenCVImpl.hpp"
#include <KurentoException.hpp>

namespace kurento {
namespace module {
namespace objdet {

static ModelPool modelPool;

ObjDetOpenCVImpl::ObjDetOpenCVImpl() {
  this->model = objdet::modelPool.getModel();
  Json::Value modelState;
  if (this->model == nullptr) {
    modelState["state"] = "000";
    modelState["msg"] = "";
  } else {
    modelState["state"] = "E001";
    modelState["msg"] = "Model not avaialbe";
  }

  modelInitState event(this->getSharedFromThis(), modelInitState::getName(), utils::jsonToString(modelState));
  signalmodelInitState(event);
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void ObjDetOpenCVImpl::process(cv::Mat &mat) {

  if (this->isInferring == true) {
    std::vector<utils::Obj> objs;
    // infer
    this->model->infer(mat, objs);

    std::vector<utils::Obj> objsTmp;
    // confidence
    for (utils::Obj &obj : objs) {
      if (obj.confi >= this->confiThresh) {
        auto it = std::lower_bound(objsTmp.begin(), objsTmp.end(), obj);
        objsTmp.insert(it, obj);
      }
    }
    objs = objsTmp;
    // box limit
    if (static_cast<int>(objs.size()) > this->boxLimit) {
      std::vector<utils::Obj> objsTmp(objs.begin(), objs.begin() + std::min(objs.size(), size_t(this->boxLimit)));
      objs = objsTmp;
    }

    // draw box
    if (this->isDraw == true) {
      utils::drawObjs(mat, mat, objs, false, 0.4);
    }

    Json::Value boxes(Json::arrayValue);
    for (utils::Obj &obj : objs) {
      Json::Value box;
      box["x1"] = obj.p1.x;
      box["y1"] = obj.p1.y;
      box["x2"] = obj.p2.x;
      box["y2"] = obj.p2.y;
      box["name"] = obj.name;
      box["confi"] = obj.confi;
      boxes.append(box);
    }
    boxDetected event(this->getSharedFromThis(), boxDetected::getName(), utils::jsonToString(boxes));
    signalboxDetected(event);
  }
}

bool ObjDetOpenCVImpl::setConfidence(float confidence) {

  if (confidence <= 0 || confidence > 1) {
    this->sendSetParamSetResult("confidence", "E001");
    return false;
  }
  this->confiThresh = std::min(std::max(confidence, 0.01f), 0.99f);
  this->sendSetParamSetResult("confidence", "000");
  return true;
}

bool ObjDetOpenCVImpl::setBoxLimit(int boxLimit) {
  if (boxLimit <= 0 || boxLimit > 100) {
    this->sendSetParamSetResult("boxLimit", "E001");
    return false;
  }
  this->boxLimit = std::min(std::max(boxLimit, 1), 100);
  this->sendSetParamSetResult("boxLimit", "000");
  return true;
}

bool ObjDetOpenCVImpl::setIsDraw(bool isDraw) {
  this->isDraw = isDraw;
  this->sendSetParamSetResult("isDraw", "000");
  return true;
}

bool ObjDetOpenCVImpl::startInferring() {
  this->isInferring = true;
  this->sendSetParamSetResult("startinferring", "000");
  return true;
}
bool ObjDetOpenCVImpl::stopInferring() {
  this->isInferring = false;
  this->sendSetParamSetResult("stopinferring", "000");
  return true;
}
bool ObjDetOpenCVImpl::destroy() {
  if (this->model != nullptr) {
    objdet::modelPool.returnModel(this->model);
    this->model = nullptr;
    this->sendSetParamSetResult("destroy", "000");
    return true;
  } else {
    this->sendSetParamSetResult("destroy", "W001");
    return false;
  }
}

void ObjDetOpenCVImpl::sendSetParamSetResult(const std::string param_name, const std::string state) {
  Json::Value result;
  result["state"] = state;
  result["param_name"] = param_name;
  paramSetState event(this->getSharedFromThis(), paramSetState::getName(), utils::jsonToString(result));
  signalparamSetState(event);
};

ObjDetOpenCVImpl::~ObjDetOpenCVImpl() {
  if (this->model != nullptr) {
    objdet::modelPool.returnModel(this->model);
  }
}

std::shared_ptr<MediaObject> ObjDetOpenCVImpl::getSharedFromThis() { return nullptr; };

} // namespace objdet
} // namespace module
} // namespace kurento
